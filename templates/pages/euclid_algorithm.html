<h1>Алгоритм Евклида нахождения НОД (наибольшего общего делителя)</h1>

<p>Даны два целых неотрицательных числа $a$ и $b$. Требуется найти их наибольший общий делитель, т.е. наибольшее число, которое является делителем одновременно и $a$, и $b$. На английском языке "наибольший общий делитель" пишется "greatest common divisor", и распространённым его обозначением является ${\rm gcd}$:</p>
$$ {\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|a \ \&\  k|b} k $$
<p>(здесь символом "$|$" обозначена делимость, т.е. "$k|a$" обозначает "$k$ делит $a$")</p>

<p>Когда оно из чисел равно нулю, а другое отлично от нуля, их наибольшим общим делителем, согласно определению, будет это второе число. Когда оба числа равны нулю, результат не определён (подойдёт любое бесконечно большое число), мы положим в этом случае наибольший общий делитель равным нулю. Поэтому можно говорить о таком правиле: если одно из чисел равно нулю, то их наибольший общий делитель равен второму числу.</p>

<p><b>Алгоритм Евклида</b>, рассмотренный ниже, решает задачу нахождения наибольшего общего делителя двух чисел $a$ и $b$ за $O(\log \min(a,b))$.</p>

<p>Данный алгоритм был впервые описан в книге Евклида "Начала" (около 300 г. до н.э)., хотя, вполне возможно, этот алгоритм имеет более раннее происхождение.</p>



<h2>Алгоритм</h2>

<p>Сам алгоритм чрезвычайно прост и описывается следующей формулой:</p>

$$ {\rm gcd}(a,b) = \cases{ a, & {\rm if} b=0 \cr {\rm gcd} (b, a\ {\rm mod}\ b), & {\rm otherwise} } $$



<h2>Реализация</h2>

\code
int gcd (int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd (b, a % b);
}
\endcode

<p>Используя тернарный условный оператор C++, алгоритм можно записать ещё короче:</p>

\code
int gcd (int a, int b) {
    return b ? gcd (b, a % b) : a;
}
\endcode

<p>Наконец, приведём и нерекурсивную форму алгоритма:</p>

\code
int gcd (int a, int b) {
    while (b) {
        a %= b;
        swap (a, b);
    }
    return a;
}
\endcode



<h2>Доказательство корректности</h2>

<p>Сначала заметим, что при каждой итерации алгоритма Евклида его второй аргумент строго убывает, следовательно, посколько он неотрицательный, то алгоритм Евклида <b>всегда завершается</b>.</p>

<p>Для <b>доказательства корректности</b> нам необходимо показать, что ${\rm gcd}(a,b) = {\rm gcd} (b, a\ {\rm mod}\ b)$ для любых $a \ge 0, b > 0$.</p>

<p>Покажем, что величина, стоящая в левой части равенства, делится на настоящую в правой, а стоящая в правой - делится на стоящую в левой. Очевидно, это будет означать, что левая и правая части совпадают, что и докажет корректность алгоритма Евклида.</p>

<p>Обозначим $d = {\rm gcd}(a,b)$. Тогда, по определению, $d|a$ и $d|b$.</p>

<p>Далее, разложим остаток от деления $a$ на $b$ через их частное:</p>
$$ a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} \right\rfloor $$

<p>Но тогда отсюда следует:</p>
$$ d\ |\ (a\ {\rm mod}\ b) $$

<p>Итак, вспоминая утверждение $d|b$, получаем систему:</p>
$$ \cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) } $$

<p>Воспользуемся теперь следующим простым фактом: если для каких-то трёх чисел $p,q,r$ выполнено: $p|q$ и $p|r$, то выполняется и: $p\ |\ {\rm gcd}(q,r)$. В нашей ситуации получаем:</p>
$$ d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$
<p>Или, подставляя вместо $d$ его определение как ${\rm gcd}(a,b)$, получаем:</p>
$$ {\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$

<p>Итак, мы провели половину доказательства: показали, что левая часть делит правую. Вторая половина доказательства производится аналогично.</p>



<h2>Время работы</h2>

<p>Время работы алгоритма оценивается <b>теоремой Ламе</b>, которая устанавливает удивительную связь алгоритма Евклида и последовательности Фибоначчи:</p>

<p>Если $a > b \ge 1$ и $b < F_n$ для некоторого $n$, то алгоритм Евклида выполнит не более $n-2$ рекурсивных вызовов.</p>

<p>Более того, можно показать, что верхняя граница этой теоремы - оптимальная. При $a = F_n, b = F_{n-1}$ будет выполнено именно $n-2$ рекурсивных вызова. Иными словами, <b>последовательные числа Фибоначчи - наихудшие входные данные</b> для алгоритма Евклида.</p>

<p>Учитывая, что числа Фибоначчи растут экспоненциально (как константа в степени $n$), получаем, что алгоритм Евклида выполняется за $O(\log \min(a,b))$ операций умножения.</p>



<h2>НОК (наименьшее общее кратное)</h2>

<p>Вычисление наименьшего общего кратного (least common multiplier, lcm) сводится к вычислению $\rm gcd$ следующим простым утверждением:</p>

$$ {\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,b) } $$

<p>Таким образом, вычисление НОК также можно сделать с помощью алгоритма Евклида, с той же асимптотикой:</p>

\code
int lcm (int a, int b) {
    return a / gcd (a, b) * b;
}
\endcode

<p>(здесь выгодно сначала поделить на $\rm gcd$, а только потом домножать на $b$, поскольку это поможет избежать переполнений в некоторых случаях)</p>



<h2>Литература</h2>

<ul>
<li>\book{Томас Кормен, Чарльз Лейзерсон, Рональд Ривест, Клиффорд Штайн}{Алгоритмы: Построение и анализ}{2005}{cormen.djvu}</li>
</ul>