<h1>Длинная арифметика</h1>

<p>Длинная арифметика - это набор программных средств (структуры данных и алгоритмы), которые позволяют работать с числами гораздо больших величин, чем это позволяют стандартные типы данных.</p>



<h2>Виды целочисленной длинной арифметики</h2>

<p>Вообще говоря, даже только в олимпиадных задачах набор средств достаточно велик, поэтому произведём классификацию различных видов длинной арифметики.</p>


<h3>Классическая длинная арифметика</h3>

<p>Основная идея заключается в том, что число хранится в виде массива его цифр.</p>

<p>Цифры могут использоваться из той или иной системы счисления, обычно применяются десятичная система счисления и её степени (десять тысяч, миллиард), либо двоичная система счисления.</p>

<p>Операции над числами в этом виде длинной арифметики производятся с помощью "школьных" алгоритмов сложения, вычитания, умножения, деления столбиком. Впрочем, к ним также применимы алгоритмы быстрого умножения: <a href="fft_multiply">Быстрое преобразование Фурье</a> и Алгоритм Карацубы.</p>

<p>Здесь описана работа только с неотрицательными длинными числами. Для поддержки отрицательных чисел необходимо ввести и поддерживать дополнительный флаг "отрицательности" числа, либо же работать в дополняющих кодах.</p>

<h4>Структура данных</h4>

<p>Хранить длинные числа будем в виде вектора чисел $int$, где каждый элемент - это одна цифра числа.</p>

\code
typedef vector<int> lnum;
\endcode

<p>Для повышения эффективности будем работать в системе по основанию миллиард, т.е. каждый элемент вектора $lnum$ содержит не одну, а сразу $9$ цифр:</p>

\code
const int base = 1000*1000*1000;
\endcode

<p>Цифры будут храниться в векторе в таком порядке, что сначала идут наименее значимые цифры (т.е. единицы, десятки, сотни, и т.д)..</p>

<p>Кроме того, все операции будут реализованы таким образом, что после выполнения любой из них лидирующие нули (т.е. лишние нули в начале числа) отсутствуют (разумеется, в предположении, что перед каждой операцией лидирующие нули также отсутствуют). Следует отметить, что в представленной реализации для числа ноль корректно поддерживаются сразу два представления: пустой вектор цифр, и вектор цифр, содержащий единственный элемент - ноль.</p>

<h4>Вывод</h4>

<p>Самое простое - это вывод длинного числа.</p>

<p>Сначала мы просто выводим самый последний элемент вектора (или $0$, если вектор пустой), а затем выводим все оставшиеся элементы вектора, дополняя их нулями до $9$ символов:</p>

\code
printf ("%d", a.empty() ? 0 : a.back());
for (int i=(int)a.size()-2; i>=0; --i)
    printf ("%09d", a[i]);
\endcode

<p>(здесь небольшой тонкий момент: нужно не забыть записать приведение типа $(int)$, поскольку в противном случае число $a.size()$ будут беззнаковым, и если $a.size() \le 1$, то при вычитании произойдёт переполнение)</p>

<h4>Чтение</h4>

<p>Считываем строку в $string$, и затем преобразовываем её в вектор:</p>

\code
for (int i=(int)s.length(); i>0; i-=9)
    if (i < 9)
        a.push_back (atoi (s.substr (0, i).c_str()));
    else
        a.push_back (atoi (s.substr (i-9, 9).c_str()));
\endcode

<p>Если использовать вместо $string$ массив $char$'ов, то код получится ещё компактнее:</p>

\code
for (int i=(int)strlen(s); i>0; i-=9) {
    s[i] = 0;
    a.push_back (atoi (i>=9 ? s+i-9 : s));
}
\endcode

<p>Если во входном числе уже могут быть лидирующие нули, то их после чтения можно удалить таким образом:</p>

\code
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
\endcode

<h4>Сложение</h4>

<p>Прибавляет к числу $a$ число $b$ и сохраняет результат в $a$:</p>

\code
int carry = 0;
for (size_t i=0; i<max(a.size(),b.size()) || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    a[i] += carry + (i < b.size() ? b[i] : 0);
    carry = a[i] >= base;
    if (carry)  a[i] -= base;
}
\endcode

<h4>Вычитание</h4>

<p>Отнимает от числа $a$ число $b$ ($a \ge b$) и сохраняет результат в $a$:</p>

\code
int carry = 0;
for (size_t i=0; i<b.size() || carry; ++i) {
    a[i] -= carry + (i < b.size() ? b[i] : 0);
    carry = a[i] < 0;
    if (carry)  a[i] += base;
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
\endcode

<p>Здесь мы после выполнения вычитания удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.</p>

<h4>Умножение длинного на короткое</h4>

<p>Умножает длинное $a$ на короткое $b$ ($b < {\rm base}$) и сохраняет результат в $a$:</p>

\code
int carry = 0;
for (size_t i=0; i<a.size() || carry; ++i) {
    if (i == a.size())
        a.push_back (0);
    long long cur = carry + a[i] * 1ll * b;
    a[i] = int (cur % base);
    carry = int (cur / base);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
\endcode

<p>Здесь мы после выполнения деления удаляем лидирующие нули, чтобы поддерживать предикат о том, что таковые отсутствуют.</p>

<p>(Примечание: способ <b>дополнительной оптимизации</b>. Если скорость работы чрезвычайно важна, то можно попробовать заменить два деления одним: посчитать только целую часть от деления (в коде это переменная $carry$), а затем уже посчитать по ней остаток от деления (с помощью одной операции умножения). Как правило, этот приём позволяет ускорить код, хотя и не очень значительно).</p>

<h4>Умножение двух длинных чисел</h4>

<p>Умножает $a$ на $b$ и результат сохраняет в $c$:</p>

\code
lnum c (a.size()+b.size());
for (size_t i=0; i<a.size(); ++i)
    for (int j=0, carry=0; j<(int)b.size() || carry; ++j) {
        long long cur = c[i+j] + a[i] * 1ll * (j < (int)b.size() ? b[j] : 0) + carry;
        c[i+j] = int (cur % base);
        carry = int (cur / base);
    }
while (c.size() > 1 && c.back() == 0)
    c.pop_back();
\endcode

<h4>Деление длинного на короткое</h4>

<p>Делит длинное $a$ на короткое $b$ ($b < {\rm base}$), частное сохраняет в $a$, остаток в $carry$:</p>

\code
int carry = 0;
for (int i=(int)a.size()-1; i>=0; --i) {
    long long cur = a[i] + carry * 1ll * base;
    a[i] = int (cur / b);
    carry = int (cur % b);
}
while (a.size() > 1 && a.back() == 0)
    a.pop_back();
\endcode


<h3>Длинная арифметика в факторизованном виде</h3>

<p>Здесь идея заключается в том, чтобы хранить не само число, а его факторизацию, т.е. степени каждого входящего в него простого.</p>

<p>Этот метод также весьма прост для реализации, и в нём очень легко производить операции умножения и деления, однако невозможно произвести сложение или вычитание. С другой стороны, этот метод значительно экономит память в сравнении с "классическим" подходом, и позволяет производить умножение и деление значительно (асимптотически) быстрее.</p>

<p>Этот метод часто применяется, когда необходимо производить деление по непростому модулю: тогда достаточно хранить число в виде степеней по простым делителям этого модуля, и ещё одного числа - остатка по этому же модулю.</p>


<h3>Длинная арифметика по системе простых модулей (Китайская теорема или схема Гарнера)</h3>

<p>Суть в том, что выбирается некоторая система модулей (обычно небольших, помещающихся в стандартные типы данных), и число хранится в виде вектора из остатков от его деления на каждый из этих модулей.</p>

<p>Как утверждает Китайская теорема об остатках, этого достаточно, чтобы однозначно хранить любое число в диапазоне от 0 до произведения этих модулей минус один. При этом имеется <a href="chinese_theorem">Алгоритм Гарнера</a>, который позволяет произвести это восстановление из модульного вида в обычную, "классическую", форму числа.</p>

<p>Таким образом, этот метод позволяет экономить память по сравнению с "классической" длинной арифметикой (хотя в некоторых случаях не столь радикально, как метод факторизации). Крому того, в модульном виде можно очень быстро производить сложения, вычитания и умножения, - все за асимптотически однаковое время, пропорциональное количеству модулей системы.</p>

<p>Однако всё это даётся ценой весьма трудоёмкого перевода числа из этого модульного вида в обычный вид, для чего, помимо немалых временных затрат, потребуется также реализация "классической" длинной арифметики с умножением.</p>

<p>Помимо этого, производить <b>деление</b> чисел в таком представлении по системе простых модулей не представляется возможным.</p>



<h2>Виды дробной длинной арифметики</h2>

<p>Операции над дробными числами встречаются в олимпиадных задачах гораздо реже, и работать с огромными дробными числами значительно сложнее, поэтому в олимпиадах встречается только специфическое подмножество дробной длинной арифметики.</p>


<h3>Длинная арифметика в несократимых дробях</h3>

<p>Число представляется в виде несократимой дроби $\frac{a}{b}$, где $a$ и $b$ - целые числа. Тогда все операции над дробными числами нетрудно свести к операциям над числителями и знаменателями этих дробей.</p>

<p>Обычно при этом для хранения числителя и знаменателя приходится также использовать длинную арифметику, но, впрочем, самый простой её вид - "классическая" длинная арифметика, хотя иногда оказывается достаточно встроенного 64-битного числового типа.</p>


<h3>Выделение позиции плавающей точки в отдельный тип</h3>

<p>Иногда в задаче требуется производить расчёты с очень большими либо очень маленькими числами, но при этом не допускать их переполнения. Встроенный $8-10$-байтовый тип $double$, как известно, допускает значения экспоненты в диапазоне $[-308; 308]$, чего иногда может оказаться недостаточно.</p>

<p>Приём, собственно, очень простой - вводится ещё одна целочисленная переменная, отвечающая за экспоненту, а после выполнения каждой операции дробное число "нормализуется", т.е. возвращается в отрезок $[0.1; 1)$, путём увеличения или уменьшения экспоненты.</p>

<p>При перемножении или делении двух таких чисел надо соответственно сложить либо вычесть их экспоненты. При сложении или вычитании перед выполнением этой операции числа следует привести к одной экспоненте, для чего одно из них домножается на $10$ в степени разности экспонент.</p>

<p>Наконец, понятно, что не обязательно выбирать $10$ в качестве основания экспоненты. Исходя из устройства встроенных типов с плавающей точкой, самым выгодным представляется класть основание равным $2$.</p>