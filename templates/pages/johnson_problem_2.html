<h1>Задача Джонсона с двумя станками</h1>



<p>Имеется $n$ деталей и два станка. Каждая деталь должна сначала пройти обработку на первом станке, затем - на втором. При этом $i$-ая деталь обрабатывается на первом станке за $a_i$ времени, а на втором - за $b_i$ времени. Каждый станок в каждый момент времени может работать только с одной деталью.</p>



<p>Требуется составить такой порядок подачи деталей на станки, чтобы итоговое время обработки всех деталей было бы минимальным.</p>



<p>Эта задача называется иногда задачей двухпроцессорного обслуживания задач, или задачей Джонсона (по имени S.M. Johnson, который в 1954 г. предложил алгоритм для её решения).</p>



<p>Стоит отметить, что когда число станков больше двух, эта задача становится NP-полной (как доказал Гэри (Garey) в 1976 г)..</p>





<h2>Построение алгоритма</h2>



<p>Заметим вначале, что можно считать, что порядок обработки деталей <b>на первом и втором станках должен совпадать</b>. В самом деле, т.к. детали для второго станка становятся доступными только после обработки на первом, а при наличии нескольких доступных для второго станка деталей время их обработки будет равно сумме их $b_i$ независимо от их порядка - то выгоднее всего отправлять на второй станок ту из деталей, которая раньше других прошла обработку на первом станке.</p>



<p>Рассмотрим порядок подачи деталей на станки, совпадающий с их входным порядком: $1, 2, \ldots, n$.</p>



<p>Обозначим через $x_i$ <b>время простоя</b> второго станка непосредственно перед обработкой $i$-ой детали (после обработки $i-1$-ой детали). Наша цель - <b>минимизировать суммарный простой</b>:</p>



$$ F(x) = \sum x_i \longrightarrow \min. $$



<p>Для первой детали мы имеем:</p>



$$ x_1 = a_1. $$



<p>Для второй - т.к. она становится готовой к отправке на второй станок в момент времени $a_1+a_2$, а второй станок освобождается в момент времени $x_1 + b_1$, то имеем:</p>



$$ x_2 = \max \Big( (a_1+a_2) - (x_1+b_1), 0 \Big). $$



<p>Третья деталь становится доступной для второго станка в момент $a_1+a_2+a_3$, а станок освобождается в $x_1+b_1+x_2+b_2$, поэтому:</p>



$$ x_3 = \max \Big( (a_1+a_2+a_3) - (x_1+b_1+x_2+b_2), 0 \Big). $$



<p>Таким образом, общий вид для $x_i$ выглядит так:</p>



$$ x_k = \max \left( \sum_{i=1}^{k} a_i - \sum_{i=1}^{k-1} b_i - \sum_{i=1}^{k-1} x_i, 0 \right). $$



<p>Посчитаем теперь <b>суммарный простой</b> $F(x)$. Утверждается, что он имеет вид:</p>



$$ F(x) = \max_{k=1 \ldots n} K_i, $$



<p>где</p>



$$ K_i = \sum_{i=1}^{k} a_i - \sum_{i=1}^{k-1} b_i. $$



(В это можно убедиться по индукции, либо последовательно находя выражения для суммы первых двух, трёх, и т.д. $x_i$).



<p>Воспользуемся теперь <b>перестановочным приёмом</b>: попробуем обменять какие-либо два соседних элемента $j$ и $j+1$ и посмотрим, как при этом изменится суммарный простой.</p>



<p>По виду функции выражений для $K_i$ понятно, что изменятся только $K_j$ и $K_{j+1}$; обозначим их новые значения через $K_j^\prime$ и $K_{j+1}^\prime$.</p>



<p>Таким образом, чтобы деталь $j$ шла до детали $j+1$, достаточно (хотя и не необходимо), чтобы:</p>



$$ \max \left( K_j, K_{j+1} \right) \le \max \left( K_j^\prime, K_{j+1}^\prime \right). $$



(т.е. мы проигнорировали остальные, не изменившиеся, аргументы максимума в выражении для $F(x)$, получив тем самым достаточное, но не необходимое условие того, что старое $F(x)$ меньше либо равно нового значения)



<p>Отняв $ \sum_{i=1}^{j+1} a_i - \sum_{i=1}^{j-1} b_i $ от обеих частей этого неравенства, получим:</p>



$$ \max (-a_{j+1}, -b_j) \le \max (-b_{j+1}, -a_j), $$



<p>или, избавляясь от отрицательных чисел, получаем:</p>



$$ \min (a_j, b_{j+1}) \le \min (b_j, a_{j+1}). $$



<p>Тем самым, мы получили <b>компаратор</b>: отсортировав детали по нему, мы, согласно приведённым выше выкладкам, придём к оптимальному порядку деталей, в котором нельзя переставить местами никакие две детали, улучшив итоговое время.</p>



<p>Впрочем, можно ещё больше <b>упростить</b> сортировку, если посмотреть на этот компаратор с другой стороны. Фактически он говорит нам о том, что если минимум из четырёх чисел $(a_j, a_{j+1}, b_{j}, b_{j+1})$ достигается на элементе из массива $a$, то соответствующая деталь должна идти раньше, а если на элементе из массива $b$ - то позже. Тем самым мы получаем другую форму алгоритма: отсортировать детали по минимуму из $(a_i, b_i)$, и если у текущей детали минимум равен $a_i$, то эту деталь надо обработать первой из оставшихся, иначе - последней из оставшихся.</p>



<p>Так или иначе, получается, что задача Джонсона с двумя станками сводится к сортировке деталей с определённой функцией сравнения элементов. Таким образом, асимптотика решения составляет $O (n \log n)$.</p>





<h2>Реализация</h2>



<p>Реализуем второй вариант описанного выше алгоритма, когда детали сортируются по минимуму из $(a_i, b_i)$, и затем отправляются в начало либо в конец текущего списка.</p>



\code

struct item {

	int a, b, id;



	bool operator< (item p) const {

		return min(a,b) < min(p.a,p.b);

	}

};





sort (v.begin(), v.end());

vector<item> a, b;

for (int i=0; i<n; ++i)

	(v[i].a<=v[i].b ? a : b) .push_back (v[i]);

a.insert (a.end(), b.rbegin(), b.rend());



int t1=0, t2=0;

for (int i=0; i<n; ++i) {

	t1 += a[i].a;

	t2 = max(t2,t1) + a[i].b;

}

\endcode



<p>Здесь все детали хранятся в виде структур $\rm item$, каждая из которых содержит значения $a$ и $b$ и исходный номер детали.</p>



<p>Детали сортируются, затем распределяются по спискам $a$ (это те детали, которые были отправлены в начало очереди) и $b$ (те, что были отправлены в конец). После этого два списка объединяются (причём второй список берётся в обратном порядке), и затем по найденному порядку вычисляется искомое минимальное время: поддерживаются две переменные $t_1$ и $t_2$ - время освобождения первого и второго станка соответственно.</p>





<h2>Литература</h2>



<ul>



<li><a href="http://www.rand.org/pubs/papers/2008/P402.pdf">S.M. Johnson. <b>Optimal two- and three-stage production schedules with setup times included</b> [1954]</a></li>



<li>M.R. Garey. <b>The Complexity of Flowshop and Jobshop Scheduling</b> [1976]</li>



</ul>