<h1>Рандомизированная куча</h1>



<p>Рандомизированная куча (randomized heap) - это куча, которая за счёт применения генератора случайных чисел позволяет выполнять все необходимые операции за логарифмическое ожидаемое время.</p>



<b>Кучей</b> называется бинарное дерево, для любой вершины которого справедливо, что значение в этой вершине меньше либо равно значений во всех её потомках (это куча для минимума; разумеется, симметрично можно определить кучу для максимума). Таким образом, в корне кучи всегда находится минимум.



<p>Стандартный набор операций, определяемый для куч, следующий:</p>

<ul>

<li>Добавление элемента</li>

<li>Нахождение минимума</li>

<li>Извлечение минимума (удаление его из дерева и возврат его значения)</li>

<li>Слияние двух куч (возвращается куча, содержащая элементы обеих куч; дубликаты не удаляются)</li>

<li>Удаление произвольного элемента (при известной позиции в дереве)</li>

</ul>



<p>Рандомизированная куча позволяет выполнять все эти операции за ожидаемое время $O(\log n)$ при очень простой реализации.</p>



<h2>Структура данных</h2>



<p>Сразу опишем структуру данных, описывающую бинарную кучу:</p>

\code

struct tree {

	T value;

	tree * l, * r;

};

\endcode

<p>В вершине дерева хранится значение $\rm value$ некоторого типа $\rm T$, для которого определён оператор сравнения ($\rm operator\ <$). Кроме того, хранятся указатели на левого и правого сыновей (которые равны 0, если соответствующий сын отсутствует).</p>



<h2>Выполнение операций</h2>



<p>Нетрудно понять, что все операции над кучей сводятся к одной операции: <b>слиянию</b> двух куч в одну. Действительно, добавление элемента в кучу равносильно слиянию этой кучи с кучей, состоящей из единственного добавляемого элемента. Нахождение минимума вообще не требует никаких действий - минимумом просто является корень кучи. Извлечение минимума эквивалентно тому, что куча заменяется результатом слияния левого и правого поддерева корня. Наконец, удаление произвольного элемента аналогично удалению минимума: всё поддерево с корнем в этой вершине заменяется результатом слияния двух поддеревьев-сыновей этой вершины.</p>



<p>Итак, нам фактически надо реализовать только операцию слияния двух куч, все остальные операции тривиально сводятся к этой операции.</p>



<p>Пусть даны две кучи $T_1$ и $T_2$, требуется вернуть их объединение. Понятно, что в корне каждой из этих куч находятся их минимумы, поэтому в корне результирующей кучи будет находиться минимум из этих двух значений. Итак, мы сравниваем, в корне какой из куч находится меньшее значение, его помещаем в корень результата, а теперь мы должны объединить сыновей выбранной вершины с оставшейся кучей. Если мы по какому-то признаку выберем одного из двух сыновей, то тогда нам надо будет просто объединить поддерево в корне с этим сыном с кучей. Таким образом, мы снова пришли к операции слияния. Рано или поздно этот процесс остановится (на это понадобится, понятно, не более чем сумма высот куч).</p>



<p>Таким образом, чтобы достичь логарифмической асимптотики в среднем, нам надо указать способ выбора одного из двух сыновей с тем, чтобы в среднем длина проходимого пути получалась бы порядка логарифма от количества элементов в куче. Нетрудно догадаться, что производить этот выбор мы будем <b>случайно</b>, таким образом, реализация операции слияния получается такой:</p>



\code

tree * merge (tree * t1, tree * t2) {

	if (!t1 || !t2)

		return t1 ? t1 : t2;

	if (t2->value < t1->value)

		swap (t1, t2);

	if (rand() & 1)

		swap (t1->l, t1->r);

	t1->l = merge (t1->l, t2);

	return t1;

}

\endcode



<p>Здесь сначала проверяется, если хотя бы одна из куч пуста, то никаких действий по слиянию производить не надо. Иначе, мы делаем, чтобы куча $\rm t1$ была кучей с меньшим значением в корне (для чего обмениваем $\rm t1$ и $\rm t2$, если надо). Наконец, мы считаем, что вторую кучу $\rm t2$ будем сливать с левым сыном корня кучи $\rm t1$, поэтому мы случайным образом обмениваем левого и правого сыновей, а затем выполняем слияние левого сына и второй кучи.</p>



<h2>Асимптотика</h2>



<p>Введём случайную величину $h(T)$, обозначающую <b>длину случайного пути</b> от корня до листа (длина в числе рёбер). Понятно, что алгоритм $\rm merge$ выполняется за $O(h(T1)+h(T2))$ операций. Поэтому для исследования асимптотики алгоритма надо исследовать случайную величину $h(T)$.</p>



<h3>Математическое ожидание</h3>



<p>Утверждается, что математическое ожидание $h(T)$ оценивается сверху логарифмом от числа $n$ вершин в этой куче:</p>

$$ Eh(T) \le \log(n+1) $$



<p>Доказывается это легко по индукции. Пусть $L$ и $R$ - соответственно левое и правое поддеревья корня кучи $T$, а $n_L$ и $n_R$ - количества вершин в них (понятно, что $n = n_L+n_R+1$).</p>



<p>Тогда справедливо:</p>

$$ Eh(T) = 1 + \frac{1}{2}(Eh(L) + Eh(R)) \le 1 + \frac{1}{2}(\log(n_L+1) + \log(n_R+1)) = $$

$$ = 1 + \log \sqrt{ (n_L+1)(n_R+1) } = \log 2 \sqrt{ (n_L+1)(n_R+1) } \le $$

$$ \le \log \frac{ 2 ((n_L+1) + (n_R+1)) }{ 2 } = \log (n_L + n_R + 2) = \log(n+1) $$

<p>что и требовалось доказать.</p>



<h3>Превышение ожидаемой оценки</h3>



<p>Докажем, что вероятность превышения полученной выше оценки мала:</p>

$$ P\{ h(T) > (c+1) \log n \} < \frac{1}{n^c} $$

<p>для любой положительной константы $c$.</p>



<p>Обозначим через $P$ множество путей от корня кучи до листьев, длина которых превосходит $(c+1) \log n$. Заметим, что для любого пути $p$ длины $|p|$ вероятность того, в качестве случайного пути будет выбран именно он, равна $2^{-|p|}$. Тогда получаем:</p>

$$ P\{ h(T) > (c+1) \log n \} = \sum_{p \in P} 2^{-|p|} < \sum_{p \in P} 2^{-(c+1) \log n} = |P| n^{-(c+1)} \le n^{-c} $$

<p>что и требовалось доказать.</p>



<h3>Асимптотика алгоритма</h3>



<p>Таким образом, алгоритм $\rm merge$, а, значит, и все остальные выраженные через него операции, выполняется за $O(\log n)$ в среднем.</p>



<p>Более того, для любой положительной константы $\epsilon$ найдётся такая положительная константа $c$, что вероятность того, что операция потребует больше чем $c \log n$ операций, меньше $n^{-\epsilon}$ (это в некотором смысле описывает худшее поведение алгоритма).</p>