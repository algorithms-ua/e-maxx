<h1>Поиск мостов</h1>



<p>Пусть дан неориентированный граф. Мостом называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности). Требуется найти все мосты в заданном графе.</p>



<p>Неформально эта задача ставится следующим образом: требуется найти на заданной карте дорог все "важные" дороги, т.е. такие дороги, что удаление любой из них приведёт к исчезновению пути между какой-то парой городов.</p>



<p>Ниже мы опишем алгоритм, основанный на \algohref=dfs{поиске в глубину}, и работающий за время $O(n+m)$, где $n$ - количество вершин, $m$ - рёбер в графе.</p>



<p>Заметим, что на сайте также описан \algohref=bridge_searching_online{онлайновый алгоритм поиска мостов} - в отличие от описанного здесь алгоритма, онлайновый алгоритм умеет поддерживать все мосты графа в изменяющемся графе (имеются в виду добавления новых рёбер).</p>





<h2>Алгоритм</h2>



<p>Запустим \algohref=dfs{обход в глубину} из произвольной вершины графа; обозначим её через $\rm root$. Заметим следующий <b>факт</b> (который несложно доказать):</p>



<ul>

<li>Пусть мы находимся в обходе в глубину, просматривая сейчас все рёбра из вершины $v$. Тогда, если текущее ребро $(v,to)$ таково, что из вершины $to$ и из любого её потомка в дереве обхода в глубину нет обратного ребра в вершину $v$ или какого-либо её предка, то это ребро является мостом. В противном случае оно мостом не является. (В самом деле, мы этим условием проверяем, нет ли другого пути из $v$ в $to$, кроме как спуск по ребру $(v,to)$ дерева обхода в глубину).</li>

</ul>



<p>Теперь осталось научиться проверять этот факт для каждой вершины эффективно. Для этого воспользуемся "временами входа в вершину", вычисляемыми \algohref=dfs{алгоритмом поиска в глубину}.</p>



<p>Итак, пусть $tin[v]$ - это время захода поиска в глубину в вершину $v$. Теперь введём массив $fup[v]$, который и позволит нам отвечать на вышеописанные запросы. Время $fup[v]$ равно минимуму из времени захода в саму вершину $tin[v]$, времён захода в каждую вершину $p$, являющуюся концом некоторого обратного ребра $(v,p)$, а также из всех значений $fup[to]$ для каждой вершины $to$, являющейся непосредственным сыном $v$ в дереве поиска:</p>



$$ fup[v] = \min \cases{

tin[v], & \cr

tin[p], & {\rm for all} (v,p){\rm\ - back edge } \cr

fup[to], & {\rm for all} (v,to){\rm\ - tree edge } \cr

} $$



(здесь "back edge" - обратное ребро, "tree edge" - ребро дерева)



<p>Тогда, из вершины $v$ или её потомка есть обратное ребро в её предка тогда и только тогда, когда найдётся такой сын $to$, что $fup[to] \le tin[v]$. (Если $fup[to] = tin[v]$, то это означает, что найдётся обратное ребро, приходящее точно в $v$; если же $fup[to] < tin[v]$, то это означает наличие обратного ребра в какого-либо предка вершины $v$).</p>



<p>Таким образом, если для текущего ребра $(v,to)$ (принадлежащего дереву поиска) выполняется $fup[to] > tin[v]$, то это ребро является мостом; в противном случае оно мостом не является.</p>





<h2>Реализация</h2>



<p>Если говорить о самой реализации, то здесь нам нужно уметь различать три случая: когда мы идём по ребру дерева поиска в глубину, когда идём по обратному ребру, и когда пытаемся пойти по ребру дерева в обратную сторону. Это, соответственно, случаи:</p>



<ul>

<li>$used[to]=false$ - критерий ребра дерева поиска;</li>

<li>$used[to]=true\ \&\&\ to \ne parent$ - критерий обратного ребра;</li>

<li>$to=parent$ - критерий прохода по ребру дерева поиска в обратную сторону.</li>

</ul>



<p>Таким образом, для реализации этих критериев нам надо передавать в функцию поиска в глубину вершину-предка текущей вершины.</p>



\code

const int MAXN = ...;

vector<int> g[MAXN];

bool used[MAXN];

int timer, tin[MAXN], fup[MAXN];



void dfs (int v, int p = -1) {

	used[v] = true;

	tin[v] = fup[v] = timer++;

	for (size_t i=0; i<g[v].size(); ++i) {

		int to = g[v][i];

		if (to == p)  continue;

		if (used[to])

			fup[v] = min (fup[v], tin[to]);

		else {

			dfs (to, v);

			fup[v] = min (fup[v], fup[to]);

			if (fup[to] > tin[v])

				IS_BRIDGE(v,to);

		}

	}

}



void find_bridges() {

	timer = 0;

	for (int i=0; i<n; ++i)

		used[i] = false;

	for (int i=0; i<n; ++i)

		if (!used[i])

			dfs (i);

}

\endcode



<p>Здесь основная функция для вызова - это ${\rm find\_bridges}$ - она производит необходимую инициализацию и запуск обхода в глубину для каждой компоненты связности графа.</p>



<p>При этом ${\rm IS\_BRIDGE}(a,b)$ - это некая функция, которая будет реагировать на то, что ребро $(a,b)$ является мостом, например, выводить это ребро на экран.</p>



<p>Константе ${\rm MAXN}$ в самом начале кода следует задать значение, равное максимально возможному числу вершин во входном графе.</p>



<p>Стоит заметить, что эта реализация некорректно работает при наличии в графе <b>кратных рёбер</b>: она фактически не обращает внимания, кратное ли ребро или оно единственно. Разумеется, кратные рёбра не должны входить в ответ, поэтому при вызове $\rm IS\_BRIDGE$ можно проверять дополнительно, не кратное ли ребро мы хотим добавить в ответ. Другой способ - более аккуратная работа с предками, т.е. передавать в $\rm dfs$ не вершину-предка, а номер ребра, по которому мы вошли в вершину (для этого надо будет дополнительно хранить номера всех рёбер).</p>





<h2>Задачи в online judges</h2>



<p>Список задач, в которых требуется искать мосты:</p>



<ul>



<li><a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=737">UVA #796 <b>"Critical Links"</b> [сложность: низкая]</a></li>



<li><a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=551">UVA #610 <b>"Street Directions"</b> [сложность: средняя]</a></li>



</ul>