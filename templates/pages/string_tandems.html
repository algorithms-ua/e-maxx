<h1>Поиск всех тандемных повторов в строке. Алгоритм Мейна-Лоренца</h1>

<p>Дана строка $s$ длины $n$.</p>

<p><b>Тандемным повтором</b> (tandem repeat) в ней называются два вхождения какой-либо подстроки подряд. Иными словами, тандемный повтор описывается парой индексов $i < j$ такими, что подстрока $s[i \ldots j]$ - это две одинаковые строки, записанные подряд.</p>

<p>Задача заключается в том, чтобы <b>найти все тандемные повторы</b>. Упрощённые варианты этой задачи: найти <b>любой</b> тандемный повтор или найти <b>длиннейший</b> тандемный повтор.</p>

<p><b>Примечание</b>. Во избежание путаницы все строки в статье мы будем считать 0-индексированными, т.е. первый символ строки имеет индекс 0.</p>

<p>Описываемый здесь алгоритм был опубликован в 1982 г. Мейном и Лоренцем (см. список литературы).</p>


<h2>Пример</h2>

<p>Рассмотрим тандемные повторы на примере какой-нибудь простой строки, например:</p>

$$ "acababaee" $$

<p>В этой строке присутствуют следующие тандемные повторы:</p>

<ul>
<li>$[2;5] = "abab"$</li>
<li>$[3;6] = "baba"$</li>
<li>$[7;8] = "ee"$</li>
</ul>

<p>Другой пример:</p>

$$ "abaaba" $$

<p>Здесь есть только два тандемных повтора:</p>

<ul>
<li>$[0;5] = "abaaba"$</li>
<li>$[2;3] = "aa"$</li>
</ul>


<h2>Число тандемных повторов</h2>

<p>Вообще говоря, тандемных повторов в строке длины $n$ может быть порядка $O(n^2)$.</p>

<p>Очевидным примером является строка, составленная из $n$ одинаковых букв - в такой строке тандемным повтором является любая подстрока чётной длины, которых примерно $n^2 / 4$. Вообще, любая периодичная строка с коротким периодом будет содержать очень много тандемных повторов</p>

<p>С другой стороны, сам по себе этот факт никак не препятствует существованию алгоритма с асимптотикой $O(n \log n)$, поскольку алгоритм может выдавать тандемные повторы в том или ином сжатом виде, группами по несколько штук сразу.</p>

<p>Более того, существует понятие <b>серий</b> - четвёрок чисел, которые описывают целую группу периодических подстрок. Было доказано, что число серий в любой строке линейно по отношению к длине строки.</p>

<p>Впрочем, описываемый ниже алгоритм не использует понятие серий, поэтому не будем детализировать это понятие.</p>

<p>Приведём здесь и другие интересные результаты, относящиеся к количеству тандемных повторов:</p>

<ul>

<li>Известно, что если рассматривать только примитивные тандемные повторы (т.е. такие, половинки которых не являются кратными строками), то их количество в любой строке - $O(n \log n)$.</li>

<li>Если кодировать тандемные повторы тройками чисел (называемыми тройками Крочемора (Crochemore)) $(i,p,r)$ (где $i$ - позиция начала, $p$ - длина повторяющейся подстроки, $r$ - количество повторов), то все тандемные повторы любой строки можно вывести с помощью $O(n \log n)$ таких троек. (Именно такой результат получается на выходе алгоритма Крочемора нахождения всех тандемных повторов).</li>

<li>Строки Фибоначчи, определяемые следующим образом:</li>

$$ t_0 = b, $$
$$ t_1 = a, $$
$$ t_i = t_{i-1} + t_{i-2}, $$

<p>являются "сильно" периодичными.</p>

<p>Число тандемных повторов в $i$-ой строке Фибоначчи длины $f_i$, даже сжатых с помощью троек Крочемора, составляет $O(f_n \log f_n)$.</p>

<p>Число примитивных тандемных повторов в строках Фибоначчи - также имеет порядок $O(f_n \log f_n)$.</p>

</ul>


<h2>Алгоритм Мейна-Лоренца</h2>

<p>Идея алгоритма Мейна-Лоренца довольно стандартна: это алгоритм <b>"разделяй-и-властвуй"</b>.</p>

<p>Кратко он заключается в том, что исходная строка разбивается пополам, решение запускается от каждой из двух половинок по отдельности (тем самым мы найдём все тандемные повторы, располагающиеся только в первой или только во второй половинке). Дальше идёт самая сложная часть - это нахождение тандемных повторов, начинающихся в первой половине и заканчивающихся во второй (назовём такие тандемные повторы для удобства <b>пересекающими</b>). Как именно это делается - и есть сама суть алгоритма Мейна-Лоренца; это мы подробно опишем ниже.</p>

<p>Асимптотика алгоритма "разделяй-и-властвуй" хорошо исследована. В частности, для нас важно, что если мы научимся искать пересекающие тандемные повторы в строке длины $n$ за $O(n)$, то итоговая асимптотика всего алгоритма получится $O(n \log n)$.</p>


<h3>Поиск пересекающих тандемных повторов</h3>

<p>Итак, алгоритм Мейна-Лоренца свёлся к тому, чтобы по заданной строке $s$ научиться искать все пересекающие тандемные повторы, т.е. такие, которые начинаются в первой половине строки, а заканчиваются - во второй.</p>

<p>Обозначим через $u$ и $v$ две половинки строки $s$:</p>

$$ s = u + v $$

<p>(их длины примерно равны длине строки $s$, делённой пополам).</p>


<h4>Правые и левые тандемные повторы</h4>

<p>Рассмотрим произвольный тандемный повтор и посмотрим на его средний символ (точнее, на тот символ, с которого начинается вторая половинка тандема; т.е. если тандемный повтор - это подстрока $s[i \ldots j]$, то средним символом будет $(i+j+1)/2$.</p>

<p>Тогда назовём тандемный повтор <b>левым или правым</b> в зависимости от того, где находится этот символ - в строке $u$ или в строке $v$. (Можно сказать и так: тандемный повтор называется левым, если большая его часть лежит в левой половине строки $s$; иначе - тандемный повтор называется правым).</p>

<p>Научимся искать <b>все левые тандемные повторы</b>; для правых всё будет аналогично.</p>


<h4>Центральная позиция $cntr$ тандемного повтора</h4>

<p>Обозначим длину искомого левого тандемного повтора через $2k$ (т.е. длина каждой половинки тандемного повтора - это $k$). Рассмотрим первый символ тандемного повтора, попадающий в строку $v$ (он стоит в строке $s$ в позиции $length(u)$). Он совпадает с символом, стоящим на $k$ позиций раньше него; обозначим эту позицию через $cntr$.</p>

<p><b>Искать все тандемные повторы мы будем, перебирая эту позицию $cntr$</b>: т.е. найдём сначала все тандемные повторы с одним значением $cntr$, затем с другим значением, и т.д. - перебирая все возможные значения $cntr$ от $0$ до $length(u)-1$.</p>

<p><b>Например</b>, рассмотрим такую строку:</p>

$$ s = "cac|ada" $$

<p>(символ вертикальной черты разделяет две половинки $u$ и $v$)</p>

<p>Тандемный повтор $"caca"$, содержащийся в этой строке, будет обнаружен, когда мы будем просматривать значение $cntr = 1$ - потому что именно в позиции $1$ стоит символ 'a', совпадающий с первым символом тандемного повтора, попавшим в половинку $v$.</p>


<h4>Критерий наличия тандемного повтора с заданным центром $cntr$</h4>

<p>Итак, мы должны научиться для зафиксированного значения $cntr$ быстро искать все тандемные повторы, соответствующие ему.</p>

<p>Получаем такую схему (для абстрактной строки, в которой содержится тандемный повтор $"abcabc"$):</p>

$$$
\setlength{\unitlength}{2mm}

\begin{picture}(30,20)

<li>nethickness{0.075mm}</li>
\put(0,10)%
{\line(0,1){2}}
\put(30,10)%
{\line(0,1){2}}
\put(0,10)%
{\line(1,0){30}}
\put(0,12)%
{\line(1,0){30}}

\put(10.5,10)%
{\line(0,1){2}}
\put(12,10)%
{\line(0,1){2}}
\put(11.25,6.1)%
{\vector(0,1){3.4}}
\put(10.5,5)%
{$cntr$}

<li>nethickness{0.4mm}</li>
\put(15,10)%
{\line(0,1){2}}
<li>nethickness{0.075mm}</li>

\put(9.3,10.5)
{a}
\put(10.8,10.5)
{b}
\put(12.3,10.5)
{c}
\put(13.8,10.5)
{a}
\put(15.3,10.5)
{b}
\put(16.8,10.5)
{c}

\put(12,12.5)%
{\oval(3,0.6)[t]}
\put(11.5,13.5)%
{$l_2$}
\put(16.5,12.5)%
{\oval(3,0.6)[t]}
\put(16,13.5)%
{$l_2$}

\put(9.75,9.5)%
{\oval(1.5,0.6)[b]}
\put(9.1,7.5)%
{$l_1$}
\put(14.25,9.5)%
{\oval(1.5,0.6)[b]}
\put(13.6,7.5)%
{$l_1$}

\end{picture}
$$$

<p>Здесь через $l_1$ и $l_2$ мы обозначили длины двух кусочков тандемного повтора: $l_1$ - это длина части тандемного повтора до позиции $cntr-1$, а $l_2$ - это длина части тандемного повтора от $cntr$ до конца половинки тандемного повтора. Таким образом, $l_1+l_2+l_1+l_2$ - это длина тандемного повтора.</p>

<p>Взглянув на эту картинку, можно понять, что <b>необходимое и достаточное</b> условие того, что с центром в позиции $cntr$ находится тандемный повтор длины $2 l = 2 (l_1 + l_2) = 2 (length(u) - cntr)$, является следующее условие:</p>

<ul>

<li>Пусть $k_1$ - это наибольшее число такое, что $k_1$ символов перед позицией $cntr$ совпадают с последними $k_1$ символами строки $u$:</li>

$$ u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ]. $$

<li>Пусть $k_2$ - это наибольшее число такое, что $k_2$ символов, начиная с позиции $cntr$, совпадают с первыми $k_2$ символами строки $v$:</li>

$$ u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ]. $$

<li>Тогда должно выполняться:</li>

$$ \cases{
l_1 \le k_1, \cr
l_2 \le k_2.
} $$

</ul>

<p>Этот критерий можно <b>переформулировать</b> таким образом. Зафиксируем конкретное значение $cntr$, тогда:</p>

<ul>

<li>Все тандемные повторы, которые мы будем сейчас обнаруживать, будут иметь длину $2 l = 2 (length(u) - cntr)$.</li>

<p>Однако таких тандемных повторов может быть <b>несколько</b>: всё зависит от выбора длин кусочков $l_1$ и $l_2 = l - l_1$.</p>

<li>Найдём $k_1$ и $k_2$, как было описано выше.</li>

<li>Тогда подходящими будут являться тандемные повторы, для которых длины кусочков $l_1$ и $l_2$ удовлетворяют условиям:</li>

$$ \cases{
l_1 + l_2 = l = length(u) - cntr, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
} $$

</ul>


<h4>Алгоритм нахождения длин $k_1$ и $k_2$</h4>

<p>Итак, вся задача сводится к быстрому вычислению длин $k_1$ и $k_2$ для каждого значения $cntr$.</p>

<p>Напомним их определения:</p>

<ul>

<li>$k_1$ - максимальное неотрицательное число, для которого выполнено:</li>

$$ u[ cntr-k_1 \ldots cntr-1 ] == u[ length(u)-k_1 \ldots length(u)-1 ]. $$

<li>$k_2$ - максимальное неотрицательное число, для которого выполнено:</li>

$$ u[ cntr \ldots cntr+k_2-1] == v[ 0 \ldots k_2-1 ]. $$

</ul>

<p>На оба этих запроса можно отвечать за $O(1)$, используя <b>\algohref=z_function{алгоритм нахождения Z-функции}</b>:</p>

<ul>

<li>Для быстрого нахождения значений $k_1$ заранее посчитаем Z-функцию для строки $\overline{u}$ (т.е. строки $u$, выписанной в обратном порядке).</li>

<p>Тогда значение $k_1$ для конкретного $cntr$ будет просто равно соответствующему значению массива Z-функции.</p>

<li>Для быстрого нахождения значений $k_2$ заранее посчитаем Z-функцию для строки $v+\#+u$ (т.е. строки $u$, приписанной к строке $v$ через символ-разделитель).</li>

<p>Опять же, значение $k_2$ для конкретного $cntr$ надо будет просто взять из соответствующего элемента Z-функции.</p>

</ul>


<h4>Поиск правых тандемных повторов</h4>

<p>До этого момента мы работали только с левыми тандемными повторами.</p>

<p>Чтобы искать правые тандемные повторы, надо действовать аналогично: мы определяем центр $cntr$ как символ, соответствующий последнему символу тандемного повтора, попавшему в первую строку.</p>

<p>Тогда длина $k_1$ будет определяться как наибольшее число символов до позиции $cntr$ включительно, совпадающих с последними символами строки $u$. Длина $k_2$ будет определяться как максимальное число символов, начиная с $cntr+1$, совпадающих с первыми символами строки $v$.</p>

<p>Таким образом, для быстрого нахождения $k_1$ и $k_2$ надо будет посчитать заранее Z-функцию для строк $\overline{u} + \# + \overline{v}$ и $v$ соответственно. После этого, перебирая конкретное значение $cntr$, мы по тому же самому критерию будем находить все правые тандемные повторы.</p>


<h4>Асимптотика</h4>

<p>Асмиптотика алгоритма Мейна-Лоренца составит, таким образом, $O(n \log n)$: поскольку этот алгоритм представляет собой алгоритм "разделяй-и-властвуй", каждый рекурсивный запуск которого работает за время, линейное относительно длины строки: для четырёх строк за линейное время ищется их \algohref=z_function{Z-функция}, а затем перебирается значение $cntr$ и выводятся все группы обнаруженных тандемных повторов.</p>

<p>Тандемные повторы обнаруживаются алгоритмом Мейна-Лоренца в виде своеобразных <b>групп</b>: таких четвёрок $(cntr, l, k_1, k_2)$, каждая из которых обозначает группу тандемных повторов с длиной $l$, центром $cntr$ и с всевозможными длинами кусочков $l_1$ и $l_2$, удовлетворяющими условиям:</p>

$$ \cases{
l_1 + l_2 = l, \cr
l_1 \le k_1, \cr
l_2 \le k_2.
} $$



<h2>Реализация</h2>

<p>Приведём реализацию алгоритма Мейна-Лоренца, которая за время $O(n \log n)$ находит все тандемные повторы данной строки в сжатом виде (в виде групп, описываемых четвёрками чисел).</p>

<p>В целях демонстрации обнаруженные тандемные повторы за время $O(n^2)$ "разжимаются" и выводятся по отдельности. Этот вывод при решении реальных задач легко будет заменить на какие-то другие, более эффективные, действия, например, на поиск наидлиннейшего тандемного повтора или подсчёт количества тандемных повторов.</p>

\code
vector<int> z_function (const string & s) {
    int n = (int) s.length();
    vector<int> z (n);
    for (int i=1, l=0, r=0; i<n; ++i) {
        if (i <= r)
            z[i] = min (r-i+1, z[i-l]);
        while (i+z[i] < n && s[z[i]] == s[i+z[i]])
            ++z[i];
        if (i+z[i]-1 > r)
            l = i,  r = i+z[i]-1;
    }
    return z;
}

void output_tandem (const string & s, int shift, bool left, int cntr, int l, int l1, int l2) {
    int pos;
    if (left)
        pos = cntr-l1;
    else
        pos = cntr-l1-l2-l1+1;
    cout << "[" << shift + pos << ".." << shift + pos+2*l-1 << "] = " << s.substr (pos, 2*l) << endl;
}

void output_tandems (const string & s, int shift, bool left, int cntr, int l, int k1, int k2) {
    for (int l1=1; l1<=l; ++l1) {
        if (left && l1 == l)  break;
        if (l1 <= k1 && l-l1 <= k2)
            output_tandem (s, shift, left, cntr, l, l1, l-l1);
    }
}

inline int get_z (const vector<int> & z, int i) {
    return 0<=i && i<(int)z.size() ? z[i] : 0;
}

void find_tandems (string s, int shift = 0) {
    int n = (int) s.length();
    if (n == 1)  return;

    int nu = n/2,  nv = n-nu;
    string u = s.substr (0, nu),
        v = s.substr (nu);
    string ru = string (u.rbegin(), u.rend()),
        rv = string (v.rbegin(), v.rend());

    find_tandems (u, shift);
    find_tandems (v, shift + nu);

    vector<int> z1 = z_function (ru),
        z2 = z_function (v + '#' + u),
        z3 = z_function (ru + '#' + rv),
        z4 = z_function (v);
    for (int cntr=0; cntr<n; ++cntr) {
        int l, k1, k2;
        if (cntr < nu) {
            l = nu - cntr;
            k1 = get_z (z1, nu-cntr);
            k2 = get_z (z2, nv+1+cntr);
        }
        else {
            l = cntr - nu + 1;
            k1 = get_z (z3, nu+1 + nv-1-(cntr-nu));
            k2 = get_z (z4, (cntr-nu)+1);
        }
        if (k1 + k2 >= l)
            output_tandems (s, shift, cntr<nu, cntr, l, k1, k2);
    }
}
\endcode


<h2>Литература</h2>

<ul>

<li><a href="http://www.cs.colorado.edu/department/publications/reports/docs/CU-CS-241-82.pdf">Michael Main, Richard J. Lorentz. <b>An O (n log n) Algorithm for Finding All Repetitions in a String</b> [1982]</a></li>

<li>Bill Smyth. <b>Computing Patterns in Strings</b> [2003]</li>

<li>Билл Смит. <b>Методы и алгоритмы вычислений на строках</b> [2006]</li>

</ul>