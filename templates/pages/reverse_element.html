<h1>Обратный элемент в кольце по модулю</h1>



<h2>Определение</h2>

<p>Пусть задан некоторый натуральный модуль $m$, и рассмотрим кольцо, образуемое этим модулем (т.е. состоящее из чисел от $0$ до $m-1$). Тогда для некоторых элементов этого кольца можно найти <b>обратный элемент</b>.</p>

<p>Обратным к числу $a$ по модулю $m$ называется такое число $b$, что:</p>

$$ a \cdot b \equiv 1 \pmod m, $$

<p>и его нередко обозначают через $a^{-1}$.</p>

<p>Понятно, что для нуля обратного элемента не существует никогда; для остальных же элементов обратный может как существовать, так и нет. Утверждается, что обратный существует только для тех элементов $a$, которые <b>взаимно просты</b> с модулем $m$.</p>

<p>Рассмотрим ниже два способа нахождения обратного элемента, работающих при условии, что он существует.</p>

<p>В завершение, рассмотрим алгоритм, который позволяет найти обратные ко всех числам по некоторому модулю за линейное время.</p>



<h2>Нахождение с помощью Расширенного алгоритма Евклида</h2>

<p>Рассмотрим вспомогательное уравнение (относительно неизвестных $x$ и $y$):</p>

$$ a \cdot x + m \cdot y = 1. $$

<p>Это <a href="diofant_2_equation">линейное диофантово уравнение второго порядка</a>. Как показано в соответствующей статье, из условия ${\rm gcd}(a,m)=1$ следует, что это уравнение имеет решение, которое можно найти с помощью <a href="extended_euclid_algorithm">Расширенного алгоритма Евклида</a> (отсюда же, кстати говоря, следует, что когда ${\rm gcd}(a,m) \ne 1$, решения, а потому и обратного элемента, не существует).</p>

<p>С другой стороны, если мы возьмём от обеих частей уравнения остаток по модулю $m$, то получим:</p>

$$ a \cdot x = 1 \pmod m. $$

<p>Таким образом, найденное $x$ и будет являться обратным к $a$.</p>

<p>Реализация (с учётом того, что найденное $x$ надо взять по модулю $m$, и $x$ могло быть отрицательным):</p>

\code
int x, y;
int g = gcdex (a, m, x, y);
if (g != 1)
    cout << "no solution";
else {
    x = (x % m + m) % m;
    cout << x;
}
\endcode

<p>Асимптотика этого решения получается $O(\log m)$.</p>



<h2>Нахождение с помощью Бинарного возведения в степень</h2>

<p>Воспользуемся теоремой Эйлера:</p>

$$ a ^ {\phi(m)} \equiv 1 \pmod m, $$

<p>которая верна как раз для случая взаимно простых $a$ и $m$.</p>

<p>Кстати говоря, в случае простого модуля $m$ мы получаем ещё более простое утверждение - малую теорему Ферма:</p>

$$ a^{m-1} \equiv 1 \pmod m. $$

<p>Умножим обе части каждого из уравнений на $a^{-1}$, получим:</p>

<ul>

<li>для любого модуля $m$:</li>

$$ a^{\phi(m)-1} \equiv a^{-1} \pmod m, $$

<li>для простого модуля $m$:</li>

$$ a^{m-2} \equiv a^{-1} \pmod m. $$

</ul>

<p>Таким образом, мы получили формулы для непосредственного вычисления обратного. Для практического применения обычно используют эффективный <a href="binary_pow">алгоритм бинарного возведения в степень</a>, который в нашем случае позволит произвести возведение в степень за $O(\log m)$.</p>

<p>Этот метод представляется несколько проще описанного в предыдущем пункте, однако он требует знания значения функции Эйлера, что фактически требует факторизации модуля $m$, что иногда может оказаться весьма сложной задачей.</p>

<p>Если же факторизация числа известна, то тогда и этот метод также работает за асимптотику $O(\log m)$.</p>



<h2>Нахождение всех простых по заданному модулю за линейное время</h2>

<p>Пусть дан простой модуль $m$. Требуется для каждого числа в отрезке $[1; m-1]$ найти обратное к нему.</p>

<p>Применяя описанные выше алгоритмы, мы получим лишь решения с асимптотикой $O(m \log m)$. Здесь же мы приведём простое решение с асимптотикой $O(m)$.</p>

<p><b>Решение</b> это выглядит следующим образом. Обозначим через $r[i]$ искомое обратное к числу $i$ по модулю $m$. Тогда для $i > 1$ верно тождество:</p>

$$ r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i]. \pmod m $$

<p><b>Реализация</b> этого удивительно лаконичного решения:</p>

\code
r[1] = 1;
for (int i=2; i<m; ++i)
    r[i] = (m - (m/i) * r[m%i] % m) % m;
\endcode

<p><b>Доказательство</b> этого решения представляет из себя цепочку простых преобразований:</p>

<p>Распишем значение $m {\rm~mod~} i$:</p>

$$ m {\rm~mod~} i = m - \left\lfloor \frac{m}{i} \right\rfloor \cdot i, $$

<p>откуда, беря обе части по модулю $m$, получаем:</p>

$$ m {\rm~mod~} i = - \left\lfloor \frac{m}{i} \right\rfloor \cdot i. \pmod m $$

<p>Умножая обе части на обратное к $i$ и обратное к $(m {\rm~mod~} i)$, получаем искомую формулу:</p>

$$ r[i] = - \left\lfloor \frac{m}{i} \right\rfloor \cdot r[m {\rm~mod~} i], \pmod m $$

<p>что и требовалось доказать.</p>