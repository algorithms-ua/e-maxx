<h1>Решето Эратосфена с линейным временем работы</h1>



<p>Дано число $n$. Требуется найти <b>все простые</b> в отрезке $[2; n]$.</p>



<p>Классический способ решения этой задачи - <b>\algohref=eratosthenes_sieve{решето Эратосфена}</b>. Этот алгоритм очень прост, но работает за время $O (n \log \log n)$.</p>



<p>Хотя в настоящий момент известно достаточно много алгоритмов, работающих за сублинейное время (т.е. за $o(n)$), описываемый ниже алгоритм интересен своей <b>простотой</b> - он практически не сложнее классического решета Эратосфена.</p>



<p>Кроме того, приводимый здесь алгоритм в качестве "побочного эффекта" фактически вычисляет <b>факторизацию всех чисел</b> в отрезке $[2; n]$, что может быть полезно во многих практических применениях.</p>



<p>Недостатком приводимого алгоритма является то, что он использует <b>больше памяти</b>, чем классическое решето Эратосфена: требуется заводить массив из $n$ чисел, в то время как классическому решету Эратосфена достаточно лишь $n$ бит памяти (что получается в $32$ раза меньше).</p>



<p>Таким образом, описываемый алгоритм имеет смысл применять только до чисел порядка $10^7$, не более.</p>



<p>Авторство алгоритма, по всей видимости, принадлежит Грайсу и Мисра (Gries, Misra, 1978 г. - см. список литературы в конце). (И, собственно говоря, называть данный алгоритм "решетом Эратосфена" некорректно: слишком отличаются эти два алгоритма).</p>





<h2>Описание алгоритма</h2>



<p>Наша цель - посчитать для каждого числа $i$ от в отрезке $[2; n]$ его <b>минимальный простой делитель</b> $lp[i]$.</p>



<p>Кроме того, нам потребуется хранить список всех найденных простых чисел - назовём его массивом $pr[]$.</p>



<p>Изначально все величины $lp[i]$ заполним нулями, что означает, что мы пока предполагаем все числа простыми. В ходе работы алгоритма этот массив будет постепенно заполняться.</p>



<p>Будем теперь перебирать текущее число $i$ от $2$ до $n$. У нас может быть два случая:</p>



<ul>



<li>$lp[i] = 0$ - это означает, что число $i$ - простое, т.к. для него так и не обнаружилось других делителей.</li>



<p>Следовательно, надо присвоить $lp[i] = i$ и добавить $i$ в конец списка $pr[]$.</p>



<li>$lp[i] \ne 0$ - это означает, что текущее число $i$ - составное, и его минимальным простым делителем является $lp[i]$.</li>



</ul>



<p>В обоих случаях дальше начинается процесс <b>расстановки значений</b> в массиве $lp[]$: мы будем брать числа, <b>кратные</b> $i$, и обновлять у них значение $lp[]$. Однако наша цель - научиться делать это таким образом, чтобы в итоге у каждого числа значение $lp[]$ было бы установлено не более одного раза.</p>



<p>Утверждается, что для этого можно поступить таким образом. Рассмотрим числа вида:</p>



$$ x_j = i \cdot p_j, $$



<p>где последовательность $p_j$ - это все простые, не превосходящие $lp[i]$ (как раз для этого нам понадобилось хранить список всех простых чисел).</p>



<p>У всех чисел такого вида проставим новое значение $lp[x_j]$ - очевидно, оно будет равно $p_j$.</p>



<p>Почему такой алгоритм корректен, и почему он работает за линейное время - см. ниже, пока же приведём его реализацию.</p>





<h2>Реализация</h2>



<p>Решето выполняется до указанного в константе числа $N$.</p>



\code

const int N = 10000000;

int lp[N+1];

vector<int> pr;



for (int i=2; i<=N; ++i) {

	if (lp[i] == 0) {

		lp[i] = i;

		pr.push_back (i);

	}

	for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j)

		lp[i * pr[j]] = pr[j];

}

\endcode



<p>Эту реализацию можно немного ускорить, избавившись от вектора $pr$ (заменив его на обычный массив со счётчиком), а также избавившись от дублирующегося умножения во вложенном цикле $for$ (для чего результат произведения надо просто запомнить в какой-либо переменной).</p>





<h2>Доказательство корректности</h2>



<p>Докажем <b>корректность</b> алгоритма, т.е. что он корректно расставляет все значения $lp[]$, причём каждое из них будет установлено ровно один раз. Отсюда будет следовать, что алгоритм работает за линейное время - поскольку все остальные действия алгоритма, очевидно, работают за $O (n)$.</p>



<p>Для этого заметим, что у любого числа $i$ <b>единственно представление</b> такого вида:</p>



$$ i = lp[i] \cdot x, $$



<p>где $lp[i]$ - (как и раньше) минимальный простой делитель числа $i$, а число $x$ не имеет делителей, меньших $lp[i]$, т.е.:</p>



$$ lp[i] \le lp[x]. $$



<p>Теперь сравним это с тем, что делает наш алгоритм - он фактически для каждого $x$ перебирает все простые, на которые его можно домножить, т.е. простые до $lp[x]$ включительно, чтобы получить числа в указанном выше представлении.</p>



<p>Следовательно, алгоритм действительно пройдёт по каждому составному числу ровно один раз, поставив у него правильное значение $lp[]$.</p>



<p>Это означает корректность алгоритма и то, что он работает за линейное время.</p>





<h2>Время работы и требуемая память</h2>



<p>Хотя асимптотика $O (n)$ лучше асимптотики $O (n \log \log n)$ классического решета Эратосфена, разница между ними невелика. На практике это означает лишь двукратную разницу в скорости, а оптимизированные варианты решета Эратосфена и вовсе не проигрывают приведённому здесь алгоритму.</p>



<p>Учитывая затраты памяти, которые требует этот алгоритм - массив чисел $lp[]$ длины $n$ и массив всех простых $pr[]$ длины примерно $n / \ln n$ - этот алгоритм кажется уступающим классическому решету по всем статьям.</p>



<p>Однако спасает его то, что массив $lp[]$, вычисляемый этим алгоритмом, позволяет искать факторизацию любого числа в отрезке $[2; n]$ за время порядка размера этой факторизации. Более того, ценой ещё одного дополнительного массива можно сделать, чтобы в этой факторизации не требовались операции деления.</p>



<p>Знание факторизации всех чисел - очень полезная информация для некоторых задач, и этот алгоритм является одним из немногих, которые позволяют искать её за линейное время.</p>





<h2>Литература</h2>



<ul>



<li>David Gries, Jayadev Misra. <b>A Linear Sieve Algorithm for Finding Prime Numbers</b> [1978]</li>



</ul>