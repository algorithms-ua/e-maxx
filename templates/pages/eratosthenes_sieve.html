<h1>Решето Эратосфена</h1>

<p>Решето Эратосфена - это алгоритм, позволяющий найти все простые числа в отрезке $[1; n]$ за $O(n \log \log n)$ операций.</p>

<p>Идея проста - запишем ряд чисел $1 \ldots n$, и будем вычеркивать сначала все числа, делящиеся на $2$, кроме самого числа $2$, затем деляющиеся на $3$, кроме самого числа $3$, затем на $5$, затем на $7$, $11$, и все остальные простые до $n$.</p>



<h2>Реализация</h2>

<p>Сразу приведём реализацию алгоритма:</p>

\code
int n;
vector<char> prime (n+1, true);
prime[0] = prime[1] = false;
for (int i=2; i<=n; ++i)
    if (prime[i])
        if (i * 1ll * i <= n)
            for (int j=i*i; j<=n; j+=i)
                prime[j] = false;
\endcode

<p>Этот код сначала помечает все числа, кроме нуля и единицы, как простые, а затем начинает процесс отсеивания составных чисел. Для этого мы перебираем в цикле все числа от $2$ до $n$, и, если текущее число $i$ простое, то помечаем все числа, кратные ему, как составные.</p>

<p>При этом мы начинаем идти от $i^2$, поскольку все меньшие числа, кратные $i$, обязательно имеют простой делитель меньше $i$, а значит, все они уже были отсеяны раньше. (Но поскольку $i^2$ легко может переполнить тип $int$, в коде перед вторым вложенным циклом делается дополнительная проверка с использованием типа $long~long$).</p>

<p>При такой реализации алгоритм потребляет $O(n)$ памяти (что очевидно) и выполняет $O(n \log \log n)$ действий (это доказывается в следующем разделе).</p>



<h2>Асимптотика</h2>

<p>Докажем, что асимптотика алгоритма равна $O(n \log \log n)$.</p>

<p>Итак, для каждого простого $p \le n$ будет выполняться внутренний цикл, который совершит $\frac{n}{p}$ действий. Следовательно, нам нужно оценить следующую величину:</p>

$$ \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} = n \cdot \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p}. $$

<p>Вспомним здесь два известных факта: что число простых, меньше либо равных $n$, приблизительно равно $\frac{n}{\ln n}$, и что $k$-ое простое число приблизительно равно $k \ln k$ (это следует из первого утверждения). Тогда сумму можно записать таким образом:</p>

$$ \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{1}{p} \approx \frac{1}{2} + \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k}. $$

<p>Здесь мы выделили первое простое из суммы, поскольку при $k = 1$ согласно приближению $k \ln k$ получится $0$, что приведёт к делению на нуль.</p>

<p>Теперь оценим такую сумму с помощью интеграла от той же функции по $k$ от $2$ до $\frac{n}{\ln n}$ (мы можем производить такое приближение, поскольку, фактически, сумма относится к интегралу как его приближение по формуле прямоугольников):</p>

$$ \sum_{k=2}^{\frac{n}{\ln n}} \frac{1}{k \ln k} \approx \int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk. $$

<p>Первообразная для подынтегральной функции есть $\ln \ln k$. Выполняя подстановку и убирая члены меньшего порядка, получаем:</p>

$$ \int\limits_2^{\frac{n}{\ln n}} \frac{1}{k \ln k}\ dk = \ln \ln \frac{n}{\ln n} - \ln \ln 2 = \ln (\ln n - \ln \ln n) - \ln \ln 2 \approx \ln \ln n. $$

<p>Теперь, возвращаясь к первоначальной сумме, получаем её приближённую оценку:</p>

$$ \sum_{ \scriptstyle p \le n, \atop\scriptstyle p~is~prime } \frac{n}{p} \approx n \ln \ln n + o(n), $$

<p>что и требовалось доказать.</p>

<p>Более строгое доказательство (и дающее более точную оценку с точностью до константных множителей) можно найти в книге Hardy и Wright "An Introduction to the Theory of Numbers" (стр. 349).</p>



<h2>Различные оптимизации решета Эратосфена</h2>

<p>Самый большой недостаток алгоритма - то, что он "гуляет" по памяти, постоянно выходя за пределы кэш-памяти, из-за чего константа, скрытая в  $O(n \log \log n)$, сравнительно велика.</p>

<p>Кроме того, для достаточно больших $n$ узким местом становится объём потребляемой памяти.</p>

<p>Ниже рассмотрены методы, позволяющие как уменьшить число выполняемых операций, так и значительно сократить потребление памяти.</p>


<h3>Просеивание простыми до корня</h3>

<p>Самый очевидный момент - что для того, чтобы найти все простые до $n$, достаточно выполнить просеивание только простыми, не превосходящими корня из $n$.</p>

<p>Таким образом, изменится внешний цикл алгоритма:</p>

\code
for (int i=2; i*i<=n; ++i)
\endcode

<p>На асимптотику такая оптимизация не влияет (действительно, повторив приведённое выше доказательство, мы получим оценку $n \ln \ln \sqrt{n} + o(n)$, что, по свойствам логарифма, асимптотически есть то же самое), хотя число операций заметно уменьшится.</p>


<h3>Решето только по нечётным числам</h3>

<p>Поскольку все чётные числа, кроме $2$, - составные, то можно вообще не обрабатывать никак чётные числа, а оперировать только нечётными числами.</p>

<p>Во-первых, это позволит вдвое сократить объём требуемой памяти. Во-вторых, это уменьшит число делаемых алгоритмом операций примерно вдвое.</p>


<h3>Уменьшение объёма потребляемой памяти</h3>

<p>Заметим, что алгоритм Эратосфена фактически оперирует с $n$ битами памяти. Следовательно, можно существенно сэкономить потребление памяти, храня не $n$ байт - переменных булевского типа, а $n$ бит, т.е. $n/8$ байт памяти.</p>

<p>Однако такой подход - <b>"битовое сжатие"</b> - существенно усложнит оперирование этими битами. Любое чтение или запись бита будут представлять из себя несколько арифметических операций, что в итоге приведёт к замедлению алгоритма.</p>

<p>Таким образом, этот подход оправдан, только если $n$ настолько большое, что $n$ байт памяти выделить уже нельзя. Сэкономив память (в $8$ раз), мы заплатим за это существенным замедлением алгоритма.</p>

<p>В завершение стоит отметить, что в языке C++ уже реализованы контейнеры, автоматически осуществляющие битовое сжатие: vector<bool> и bitset<>. Впрочем, если скорость работы очень важна, то лучше реализовать битовое сжатие вручную, с помощью битовых операций - на сегодняшний день компиляторы всё же не в состоянии генерировать достаточно быстрый код.</p>


<h3>Блочное решето</h3>

<p>Из оптимизации "просеивание простыми до корня" следует, что нет необходимости хранить всё время весь массив $prime[1 \ldots n]$. Для выполнения просеивания достаточно хранить только простые до корня из $n$, т.е. $prime[1 \ldots \sqrt{n}]$, а остальную часть массива $prime$ строить поблочно, храня в текущий момент времени только один блок.</p>

<p>Пусть $s$ - константа, определяющая размер блока, тогда всего будет $\left\lceil \frac{n}{s} \right\rceil$ блоков, $k$-ый блок ($k = 0 \ldots \left\lfloor \frac{n}{s} \right\rfloor$) содержит числа в отрезке $[ks; ks+s-1]$. Будем обрабатывать блоки по очереди, т.е. для каждого $k$-го блока будем перебирать все простые (от $1$ до $\sqrt{n}$) и выполнять ими просеивание только внутри текущего блока. Аккуратно стоит обрабатывать первый блок - во-первых, простые из $[1; \sqrt{n}]$ не должны удалить сами себя, а во-вторых, числа $0$ и $1$ должны особо помечаться как не простые. При обработке последнего блока также следует не забывать о том, что последнее нужное число $n$ не обязательно находится в конце блока.</p>

<p>Приведём реализацию блочного решета. Программа считывает число $n$ и находит количество простых от $1$ до $n$:</p>

\code
const int SQRT_MAXN = 100000; // корень из максимального значения N
const int S = 10000;
bool nprime[SQRT_MAXN], bl[S];
int primes[SQRT_MAXN], cnt;

int main() {

    int n;
    cin >> n;
    int nsqrt = (int) sqrt (n + .0);
    for (int i=2; i<=nsqrt; ++i)
        if (!nprime[i]) {
            primes[cnt++] = i;
            if (i * 1ll * i <= nsqrt)
                for (int j=i*i; j<=nsqrt; j+=i)
                    nprime[j] = true;
        }

    int result = 0;
    for (int k=0, maxk=n/S; k<=maxk; ++k) {
        memset (bl, 0, sizeof bl);
        int start = k * S;
        for (int i=0; i<cnt; ++i) {
            int start_idx = (start + primes[i] - 1) / primes[i];
            int j = max(start_idx,2) * primes[i] - start;
            for (; j<S; j+=primes[i])
                bl[j] = true;
        }
        if (k == 0)
            bl[0] = bl[1] = true;
        for (int i=0; i<S && start+i<=n; ++i)
            if (!bl[i])
                ++result;
    }
    cout << result;

}
\endcode

<p>Асимптотика блочного решета такая же, как и обычного решета Эратосфена (если, конечно, размер $s$ блоков не будет совсем маленьким), зато объём используемой памяти сократится до $O(\sqrt{n} + s)$ и уменьшится "блуждание" по памяти. Но, с другой стороны, для каждого блока для каждого простого из $[1; \sqrt{n}]$ будет выполняться деление, что будет сильно сказываться при меньших размерах блока. Следовательно, при выборе константы $s$ необходимо соблюсти баланс.</p>

<p>Как показывают эксперименты, наилучшая скорость работы достигается, когда $s$ имеет значение приблизительно от $10^4$ до $10^5$.</p>


<h3>Улучшение до линейного времени работы</h3>

<p>Алгоритм Эратосфена можно преобразовать в другой алгоритм, который уже будет работать за линейное время - см. статью \algohref=prime_sieve_linear{"Решето Эратосфена с линейным временем работы"}. (Впрочем, этот алгоритм имеет и недостатки).</p>