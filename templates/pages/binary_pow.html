<h1>Бинарное возведение в степень</h1>





<p>Бинарное (двоичное) возведение в степень - это приём, позволяющий возводить любое число в $n$-ую степень за $O(\log n)$ умножений (вместо $n$ умножений при обычном подходе).</p>



<p>Более того, описываемый здесь приём применим к любой <b>ассоциативной</b> операции, а не только к умножению чисел. Напомним, операция называется ассоциативной, если для любых $a, b, c$ выполняется:</p>

$$ (a \cdot b) \cdot c = a \cdot (b \cdot c) $$



<p>Наиболее очевидное обобщение - на остатки по некоторому модулю (очевидно, ассоциативность сохраняется). Следующим по "популярности" является обобщение на произведение матриц (его ассоциативность общеизвестна).</p>







<h2>Алгоритм</h2>



<p>Заметим, что для любого числа $a$ и <b>чётного</b> числа $n$ выполнимо очевидное тождество (следующее из ассоциативности операции умножения):</p>

$$ a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2} $$

<p>Оно и является основным в методе бинарного возведения в степень. Действительно, для чётного $n$ мы показали, как, потратив всего одну операцию умножения, можно свести задачу к вдвое меньшей степени.</p>



<p>Осталось понять, что делать, если степень $n$ <b>нечётна</b>. Здесь мы поступаем очень просто: перейдём к степени $n-1$, которая будет уже чётной:</p>

$$ a^n = a^{n-1} \cdot a $$



<p>Итак, мы фактически нашли рекуррентную формулу: от степени $n$ мы переходим, если она чётна, к $n/2$, а иначе - к $n-1$. Понятно, что всего будет не более $2 \log n$ переходов, прежде чем мы придём к $n = 0$ (базе рекуррентной формулы). Таким образом, мы получили алгоритм, работающий за $O (\log n)$ умножений.</p>







<h2>Реализация</h2>



<p>Простейшая рекурсивная реализация:</p>



\code

int binpow (int a, int n) {

	if (n == 0)

		return 1;

	if (n % 2 == 1)

		return binpow (a, n-1) * a;

	else {

		int b = binpow (a, n/2);

		return b * b;

	}

}

\endcode



<p>Нерекурсивная реализация, также оптимизированная (деления на 2 заменены битовыми операциями):</p>



\code

int binpow (int a, int n) {

	int res = 1;

	while (n)

		if (n & 1) {

			res *= a;

			--n;

		}

		else {

			a *= a;

			n >>= 1;

		}

	return res;

}

\endcode



<p>Эту реализацию можно ещё несколько упростить, заметив, что возведение $a$ в квадрат осуществляется всегда, независимо от того, сработало условие нечётности $n$ или нет:</p>



\code

int binpow (int a, int n) {

	int res = 1;

	while (n) {

		if (n & 1)

			res *= a;

		a *= a;

		n >>= 1;

	}

	return res;

}

\endcode



<p>Наконец, стоит отметить, что бинарное возведение в степень уже реализовано в языке Java, но только для класса длинной арифметики BigInteger (функция pow этого класса работает именно по алгоритму бинарного возведения).</p>







<h2>Примеры решения задач</h2>





<h3>Эффективное вычисление чисел Фибоначчи</h3>



<b>Условие</b>. Дано число $n$. Требуется вычислить $F_n$, где $F_i$ - \algohref=fibonacci_numbers{последовательность чисел Фибоначчи}.



<b>Решение</b>. Более подробно это решение описано в \algohref=fibonacci_numbers{статье о последовательности Фибоначчи}. Здесь же мы лишь кратко приведём суть этого решения.



<p>Основная идея следующая. Вычисление очередного числа Фибоначчи основывается на знании двух предыдущих чисел Фибоначчи: а именно, каждое следующее число Фибоначчи получается как сумма двух предыдущих. Это означает, что мы можем построить матрицу $2 \times 2$, которая будет соответствовать этому преобразованию: как по двум числам Фибоначчи $F_i$ и $F_{i+1}$ вычислить следующее число, т.е. перейти к паре $F_{i+1}$, $F_{i+2}$. Например, применяя это преобразование $n$ раз к паре $F_0$ и $F_1$, мы получим пару $F_n$ и $F_{n+1}$. Таким образом, возведя матрицу этого преобразования в $n$-ую степень, мы тем самым найдём искомое $F_n$ за время $O (\log n)$, что нам и требовалось.</p>





<h3>Возведение перестановки в $k$-ую степень</h3>



<b>Условие</b>. Дана перестановка $p$ длины $n$. Требуется возвести её в $k$-ую степень, т.е. найти, что получится, если к тождественной перестановке $k$ раз применить перестановку $p$.



<b>Решение</b>. Просто применим к перестановке $p$ описанный выше алгоритм бинарного возведения в степень. Никаких отличий по сравнению с возведением чисел в степень - нет. Решение получается с асимптотикой $O (n \log k)$.



(Примечание. Данную задачу можно решить и более эффективно, <b>за линейное время</b>. Для этого достаточно выделить в перестановке все циклы, после чего рассмотреть по отдельности каждый цикл и, взяв $k$ по модулю длины текущего цикла, найти ответ для этого цикла).





<h3>Быстрое применение набора геометрических операций к точкам</h3>



<b>Условие</b>. Даны $n$ точек $p_i$, и даны $m$ преобразований, которые надо применить к каждой из этих точек. Каждое преобразование - это либо сдвиг на заданный вектор, либо масштабирование (умножение координат на заданные коэффициенты), либо вращение вокруг заданной оси на заданный угол. Кроме того, имеется составная операция циклического повторения: она имеет вид "повторить заданное число раз заданный список преобразований" (операции циклического повторения могут вкладываться друг в друга).



<p>Требуется вычислить результат применения указанных операций ко всем точкам (эффективно, т.е. за время, меньшее чем $O(n \cdot length)$, где $length$ - общее количество операций, которые необходимо сделать).</p>



<b>Решение</b>. Посмотрим на разные виды преобразований с точки зрения того, как они изменяют координаты:



<ul>



<li>Операция сдвига - она просто прибавляет ко всем координатам единицу, домноженную на некоторые константы.</li>



<li>Операция масштабирования - она умножает каждую координату на некоторую константу.</li>



<li>Операция вращения вокруг оси - её можно представить следующим образом: новые получаемые координаты можно записать как линейную комбинацию старых.</li>



(Мы не будем здесь уточнять, каким образом это производится. Например, можно для простоты представить это в виде комбинации пяти двумерных поворотов: сначала в плоскостях $OXY$ и $OXZ$ так, чтобы ось вращения совпала с положительным направлением оси $OX$, затем требуемый поворот вокруг оси в плоскости $YZ$, затем обратные повороты в плоскостях $OXZ$ и $OXY$ так, чтобы ось вращения вернулась в своё исходное положение).



</ul>



<p>Как легко видеть, каждое из этих преобразований - это пересчёт координат по линейным формулам. Таким образом, любое такое преобразование можно записать в виде матрицы $4 \times 4$:</p>



$$ \begin{pmatrix}

a_11 & a_{12} & a_{13} & a_{14} \\

a_21 & a_{22} & a_{23} & a_{24} \\

a_31 & a_{32} & a_{33} & a_{34} \\

a_41 & a_{42} & a_{43} & a_{44} \\

\end{pmatrix}, $$



<p>которое при умножении (слева) на строку из старых координат и константы-единицы даёт строку из новых координат и константы-единицы:</p>



$$ \begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot \begin{pmatrix}

a_{11} & a_{12} & a_{13} & a_{14} \\

a_{21} & a_{22} & a_{23} & a_{24} \\

a_{31} & a_{32} & a_{33} & a_{34} \\

a_{41} & a_{42} & a_{43} & a_{44} \\

\end{pmatrix} = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}. $$



(Почему понадобилось вводить фиктивную четвёртую координату, всегда равную единице? Без этого не получилось бы реализовать операцию сдвига: ведь сдвиг - это как раз прибавление к координатам единицы, домноженной на некоторые коэффициенты. Без фиктивной единицы мы бы смогли только реализовывать линейные комбинации самих координат, а прибавлять к ним заданные константы - не смогли бы).



<p>Теперь решение задачи становится почти тривиальным. Раз каждая элементарная операция описывается матрицей, то последовательность операций описывается произведением этих матриц, а операция циклического повторения - возведением этой матрицы в степень. Таким образом, мы за время $O (m \cdot \log repetition)$ можем предпосчитать матрицу $4 \times 4$, описывающую все преобразования, и затем просто умножить каждую точку $p_i$ на эту матрицу - тем самым, мы ответим на все запросы за время $O (n)$.</p>





<h3>Количество путей фиксированной длины в графе</h3>



<b>Условие</b>. Дан неориентированный граф $G$ с $n$ вершинами, и дано число $k$. Требуется для каждой пары вершин $i$ и $j$ найти количество путей между ними, содержащих ровно $k$ рёбер.



<b>Решение</b>. Более подробно эта задача рассматривается в \algohref=fixed_length_paths{отдельной статье}. Здесь же лишь напомним суть этого решения: мы просто возводим в $k$-ую степень матрицу смежности этого графа, и элементы этой матрицы и будут являться решениями. Итоговая асимптотика - $O (n^3 \log k)$.



(Примечание. В \algohref=fixed_length_paths{той же статье} рассматривается и другая вариация этой задачи: когда граф взвешенный, и требуется найти путь минимального веса, содержащий ровно $k$ рёбер. Как показано в этой статье, данная задача также решается с помощью бинарного возведения в степень матрицы смежности графа, однако вместо обычной операции перемножения двух матриц следует использовать модифицированную: вместо умножений берётся сумма, а вместо суммирования - взятие минимума).





<h3>Вариация бинарного возведения в степень: перемножение двух чисел по модулю</h3>



<p>Приведём здесь интересную вариацию бинарного возведения в степень.</p>



<p>Пусть перед нами стоит такая <b>задача</b>: перемножить два числа $a$ и $b$ по модулю $m$:</p>



$$ a \cdot b \pmod m $$



<p>Предположим, что числа могут быть достаточно велики: настолько, что сами числа помещаются во встроенные типы данных, а вот их непосредственное произведение $a \cdot b$ - уже нет (отметим, что нам также потребуется, чтобы сумма чисел помещалась во встроенный тип данных). Соответственно, задача в том, чтобы посчитать искомую величину $(a \cdot b) \pmod m$, не прибегая к помощи \algohref=big_integer{длинной арифметики}.</p>



<b>Решение</b> таково. Мы просто применяем алгоритм бинарного возведения, описанный выше, только вместо операции умножения мы будем производить сложения. Иными словами, перемножение двух чисел мы свели к $O (\log m)$ операций сложения и умножения на два (что тоже, по сути, есть сложение).



(Примечание. Данную задачу можно решить и <b>по-другому</b>, прибегнув к помощи операций с числами с плавающей точкой. А именно, посчитаем в числах с плавающей точкой выражение $a \cdot b / m$, и округлим его к ближайшему целому. Так мы найдём <b>приблизительное</b> частное. Отняв его от произведения $a \cdot b$ (проигнорировав переполнения), мы, скорее всего, получим относительно небольшое число, которое можно взять по модулю $m$ - и вернуть его в качестве ответа. Это решение выглядит довольно ненадёжным, но оно весьма быстрое, и очень кратко реализуется).







<h2>Задачи в online judges</h2>



<p>Список задач, которые можно решить, используя бинарное возведение в степень:</p>



<ul>



<li><a href="http://acm.sgu.ru/problem.php?contest=0&problem=265">SGU #265 <b>"Wizards"</b> [сложность: средняя]</a></li>



</ul>



