<h1>Бінарне піднесення в степінь за O(log N)</h1>

<p>
    Бінарне (двійкове) піднесення в степінь - це алгоритм, що дозволяє підносити будь-яке число в $n$-у степінь за $O(\log n)$ множень (замість $n$ множень
    при звичайному підході).
</p>

<p>
    Крім того, описаний тут алгоритм застосуємо до будь-якої <b>асоціативної</b> операції, а не тільки до множення чисел. Нагадаємо, операція
    називається асоціативною, якщо для будь-яких $a, b, c$ виконується:
</p>
$$ (a \cdot b) \cdot c = a \cdot (b \cdot c) $$

<p>
    Найчастіше використовується узагальнення - обчислення остачі за деяким модулем (асоціативність також зберігається). Наступним за частотою використання є
    узагальнення на добуток матриць (асоціативність загальновідома).
</p>



<h2>Алгоритм</h2>

<p>Зауважимо, що для будь-якого числа $a$ і <b>парного</b> числа $n$ виконується тотожність (випливає з асоціативності операції множення):</p>
$$ a^n = (a^{n/2})^2 = a^{n/2} \cdot a^{n/2} $$
<p>
    Вона і є основною в методі бінарного піднесення в степінь. Дійсно, для парного $n$ ми показали, як, витративши всього лиш одну операцію множення, можна
    звести до задачі з вдвічі меншим степенем.
</p>

<p>Залишилося зрозуміти, що робити, якщо степінь $n$ <b>непарна</b>. Тут все дуже просто: перейдемо до степені $n-1$, яка вже буде парною:</p>
$$ a^n = a^{n-1} \cdot a $$

<p>
    Отже, ми фактично знайшли рекурентну формулу: від степені $n$ ми переходимо, якщо вона парна, до $n/2$, а інакше - до $n-1$. Зрозуміло, що всього буде
    не більше $2 \log n$ переходів, перш ніж ми прийдемо до $n = 0$ (до бази рекурентної формули). Таким чином, ми отримали алгоритм, що працює
    за $O(\log n)$ множень.
</p>



<h2>Реалізація</h2>

<p>Рекурсивна реалізація:</p>

{{ format_code('binpow_recursive.cpp') }}

<p>Нерекурсивна реалізація із оптимізованими діленнями на 2, які замінені бітовими операціями:</p>

{{ format_code('binpow_loop.cpp') }}

<p>
    Цю реалізацію можна ще трішки оптимізувати, помітивши, що піднесення $a$ в квадрат здійснюється завжди, незалежно від того,
    спрацювала умова непарності $n$ чи ні:
</p>

{{ format_code('binpow_loop_optimized.cpp') }}

<p>
    Також, варто підмітити, що бінарне піднесення в степінь вже реалізовано у мові Java, але тільки для класу з довгою арифметикою BigInteger (функція pow
    цього класу працює використовуючи описаний алгоритм).
</p>



<h2>Застосування</h2>


<h3>Ефективне обчислення чисел Фібоначчі</h3>

<p><b>Умова</b>. Дано число $n$. Потрібно обчислити $F_n$, де $F_i$ - <a href="fibonacci_numbers">послідовність чисел Фібоначчі</a>.</p>

<p>
    <b>Розв'язок</b>. Більш детально цей розв'язок описано в <a href="fibonacci_numbers">статті про послідовності Фібоначчі</a>. Тут ми лише коротко
    наведемо його суть.
</p>

<p>
    Основна ідея наступна. Обчислення чергового числа Фібоначчі базується на знанні двох попередніх чисел Фібоначчі: а саме, кожне наступне число Фібоначчі
    обчислюється як сума двох попередніх. Це означає, що ми можемо побудувати матрицю $2 \times 2$, яка буде відповідати наступному перетворенню: як маючи два
    числа Фібоначчі $F_i$ та $F_{i+1}$ обчислити наступне число, тобто перейти до пари $F_{i+1}$, $F_{i+2}$. Застосовуючи це перетворення $n$ раз до пари
    $F_0$ та $F_1$, ми отримаємо пару $F_n$ і $F_{n+1}$. Таким чином, підносячи матрицю цього перетворення в $n$-у степінь, ми знайдемо шукане $F_n$
    за час $O(\log n)$, що нам і було потрібно.
<p></p>


<h3>Піднесення перестановки в $k$-у степінь</h3>

<p>
    <b>Умова</b>. Дано перестановку $p$ довжини $n$. Потрібно піднести її в $k$-у степінь, тобто знайти, що вийде, якщо до тотожної перестановки $k$ раз
    застосувати перестановку $p$.
</p>

<p>
    <b>Розв'язок</b>. Застосуємо до перестановки $p$ описаний вище алгоритм бінарного піднесення в степінь. Жодних відмінностей із піднесенням чисел у степінь
    немає. Одержуємо розв'язок з асимптотикою $O(n \log k)$.
</p>

<p>
    (Зауваження. Дану задачу можна розв'язати ефективніше - <b>за лінійний час</b>. Для цього достатньо виділити у перестановці всі цикли, після чого розглянути
    окремо кожний цикл і, взявши $k$ за модулем довжини поточного циклу, знайти відповідь для цього циклу).
</p>


<h3>Швидке застосування набору геометричних операцій до точок</h3>

<p>
    <b>Умова</b>. Дано $n$ точок $p_i$ та $m$ перетворень, які треба застосувати до кожної з цих точок. Кожне перетворення - це або зсув на заданий вектор, або
    масштабування (множення координат на задані коефіцієнти), або обертання навколо заданої осі на заданий кут. Крім того, є складена операція циклічного
    повторення, яка має вигляд - "повторити задане число раз заданий список перетворень" (операції циклічного повторення можуть вкладатися один в одного).
</p>

<p>
    Потрібно обчислити результат застосування заданих операцій до всіх точок за час, менший ніж $O(n \cdot length)$, де $length$ - загальна кількість операцій,
    які необхідно зробити.
</p>

<p><b>Розв'язок</b>. Розглянемо різні види перетворень з точки зору того, як вони змінюють координати:</p>

<ul>
    <li>Операція зсуву - просто додає до всіх координат одиницю, помножену на деякі константи.</li>
    <li>Операція масштабування - множить кожну координату на деяку константу.</li>
    <li>
        <p>Операція обертання навколо осі - її можна уявити наступним чином: нові одержані координати можна записати у вигляді лінійної комбінації старих.</p>
        <p>
            (Наприклад, можна уявити у вигляді комбінації п'яти двовимірних поворотів: спочатку в площинах $OXY$ і $OXZ$ так, аби вісь обертання співпала з
            позитивним напрямом осі $OX$, потім необхідний поворот навколо осі в площині $YZ$, потім зворотні повороти в площинах $OXZ$ і $OXY$ так,
            аби вісь обертання повернулась у своє вихідне положення).
        </p>
    </li>
</ul>

<p>
    Кожне з цих перетворень - це переобчислення координат за лінійними формулами. Таким чином, будь-яке таке перетворення можна записати у вигляді
    матриці $4 \times 4$:
</p>

$$ \begin{pmatrix}
a_11 & a_{12} & a_{13} & a_{14} \\
a_21 & a_{22} & a_{23} & a_{24} \\
a_31 & a_{32} & a_{33} & a_{34} \\
a_41 & a_{42} & a_{43} & a_{44} \\
\end{pmatrix}, $$

<p>яке при множенні (ліворуч) на рядок з старими координатами і константи-одиниці дає рядок з новими координатами і константами-одиницями:</p>

$$ \begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot \begin{pmatrix}
a_{11} & a_{12} & a_{13} & a_{14} \\
a_{21} & a_{22} & a_{23} & a_{24} \\
a_{31} & a_{32} & a_{33} & a_{34} \\
a_{41} & a_{42} & a_{43} & a_{44} \\
\end{pmatrix} = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}. $$

<p>
    (Для чого введено фіктивну четверту координату, що завжди рівна одиниці? Без цього не вийшло б реалізувати операцію зсуву, адже зсув - це як раз
    доданок до координат одиниці, що помножена на деякі коефіцієнти. Без фіктивної одиниці ми б змогли тільки реалізовувати лінійні комбінації самих координат,
    а додавати до них задані константи - не змогли б).
</p>

<p>
    Тепер розв'язок задачі стає простим. Оскільки кожна елементарна операція описується матрицею, то послідовність операцій описується добутком цих матриць,
    а операція циклічного повторення - піднесення цієї матриці в степінь. Таким чином, ми за час $O(m \cdot \log repetition)$ можемо зазделегідь обчислити
    матрицю $4 \times 4$, що описує всі перетворення, і потім просто помножити кожну точку $p_i$ на цю матрицю - тим самим, ми дамо відповідь на всі запити за
    час $O(n)$.
</p>


<h3>Кількість шляхів фіксованої довжини у графі</h3>

<p>
    <b>Умова</b>. Дано неорієнтований граф $G$ з $n$ вершинами, і дано число $k$. Потрібно для кожної пари вершин $i$ і $j$ знайти кількість шляхів між ними,
    що містять рівно $k$ ребер.
</p>

<p>
    <b>Розв'язок</b>. Більш детально цю задачу розглянуто у <a href="fixed_length_paths">окремій статті</a>. Тут лише описано суть цього розв'язку: ми
    підносимо в $k$-у степінь матрицю суміжності цього графа, і елементи цієї матриці і будуть мати шукані значення. Асимптотика - $O(n^3 \log k)$.
</p>

<p>
    (Зауваження. У <a href="fixed_length_paths">згаданій статті</a> розглядається також й інший варіант цієї задачі: коли граф зважений, і потрібно знайти шлях
    мінімального ваги, що містить рівно $k$ ребер. Дана задача також вирішується з допомогою бінарного піднесення в степінь матриці суміжності графа, однак
    замість звичайної операції перемноження двох матриць використовують модифіковану: замість множень береться сума, а замість підсумовування - взяття
    мінімуму).
</p>


<h3>Добуток двох чисел за модулем</h3>

<p><b>Умова</b>. Дано два додатних цілих числа $a$ і $b$. Потрібно знайти значення їх добутку за модулем $m$:</p>

$$ a \cdot b \pmod m $$

<p>
    Припустимо, що числа можуть бути достатньо великі: настільки, що самі числа поміщаються у базові типи даних, а ось їх добуток $a \cdot b$ - вже ні
    (відзначимо, що нам також буде потрібно, аби сума чисел поміщалась у базові типи даних). Відповідно, задача в тому, щоб порахувати шукану величину
    $(a \cdot b) \pmod m$, не застосовуючи <a href="big_integer">довгу арифметику</a>.</p>

<p>
    <b>Розв'язок</b>. Застосуємо алгоритм бінарного піднесення, описаний вище, тільки замість операції множення ми будемо використовувати додавання.
    Іншими словами, перемноження двох чисел ми звели до $O(\log m)$ операцій додавання і множення на два (що теж, по суті, є додавання).
</p>

$$
f(a, b) = 
\begin{cases}
0 &\text{якщо }a = 0 \\\\
f(\frac{a}{2}, 2 b) &\text{якщо }a > 0 \text{ і }a \text{ парне} \\\\
f(\frac{a-1}{2}, 2 b) + b &\text{якщо }a > 0 \text{ і }a \text{ непарне}
\end{cases}
$$

<p>Реалізація:</p>

{{ format_code('binprod_mod.cpp') }}

<p>
    (Зауваження. Дану задачу можна розв'язати і <b>по-іншому</b>, використавши операції над числами з рухомою точкою. А саме, порахуємо в числах
    з рухомою точкою вираз $a \cdot b / m$, і заокруглимо його до найближчого цілого числа. Так ми знайдемо <b>приблизну</b> частку. Віднявши її від добутку
    $a \cdot b$ (проігнорувавши переповнення), ми, швидше всього, отримаємо деяке невелике число, яке можна взяти за модулем $m$ і повернути результат в якості
    відповіді. Цей розв'язок виглядає досить надійним та швидким і він дуже коротко реалізується).
</p>

<h2>Задачі</h2>

<p>Список задач, які можна розв'язати, використовуючи бінарне піднесення в степінь:</p>

<ul>
    <li>
        <a href="http://acm.sgu.ru/problem.php?contest=0&problem=265">
            SGU #265 <b>"Wizards"</b> [складність: середня]
        </a>
    </li>
</ul>

